#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <pthread.h>
#include <semaphore.h>

// Semáforos globais
sem_t mutex;
sem_t cheio;
sem_t vazio;

// Ponteiro para a fila do buffer
int *buffer;

// Tamanho do buffer
int N_BUFFER;

// Número de produtores
int PROD_NUM;

// Posições de controle de leitura e escrita no buffer
int in = 0;
int out = 0;

// Protótipos das funções
void *producer(void *);
void *consumer();
int gera_rand(int);
void print_buffer();

int main(int argc, char **argv)
{
    pthread_t tcons;
    pthread_t *nprod;
    long i;

    if (argc != 3)
    {
        printf("Usage: %s buffer_size num_producers\n", argv[0]);
        return 0;
    }

    srand(time(NULL));

    N_BUFFER = atoi(argv[1]);
    PROD_NUM = atoi(argv[2]);

    // Inicializa os semáforos
    sem_init(&mutex, 0, 1);
    sem_init(&cheio, 0, 0);
    sem_init(&vazio, 0, N_BUFFER);

    buffer = malloc(N_BUFFER * sizeof(int));
    for (i = 0; i < N_BUFFER; i++)
        buffer[i] = -1;

    nprod = malloc(PROD_NUM * sizeof(pthread_t));

    pthread_create(&tcons, NULL, consumer, NULL);

    for (i = 0; i < PROD_NUM; i++)
        pthread_create(&nprod[i], NULL, producer, (void *)i);

    for (i = 0; i < PROD_NUM; i++)
        pthread_join(nprod[i], NULL);

    pthread_join(tcons, NULL);

    // Destroi os semáforos
    sem_destroy(&mutex);
    sem_destroy(&cheio);
    sem_destroy(&vazio);

    free(buffer);
    free(nprod);

    return 0;
}

void *consumer()
{
    usleep(gera_rand(1000000));

    int produto;
    int i = 0;

    while (i != PROD_NUM)
    {
        printf("- Consumidor esperando por recurso!\n");
        print_buffer();

        sem_wait(&cheio);     // Espera até haver item disponível
        sem_wait(&mutex);     // Entra na seção crítica

        printf("- Consumidor entrou em ação!\n");
        print_buffer();

        produto = buffer[out];
        printf("\t- Consumidor vai limpar posição %d\n", out);
        printf("\t- Consumiu o valor: %d\n", produto);

        if (produto == -1)
        {
            printf("==== ALERTA DO CONSUMIDOR ====\n");
            printf("Posicao %d estava vazia\n", out);
            printf("==============================\n");
        }

        buffer[out] = -1;
        out = (out + 1) % N_BUFFER;

        sem_post(&mutex);     // Sai da seção crítica
        sem_post(&vazio);     // Indica espaço livre

        i++;
    }

    return NULL;
}

void *producer(void *id)
{
    usleep(gera_rand(1000000));

    long i = (long)id;
    int produto;

    printf("> Produtor %ld esperando por recurso!\n", i);

    sem_wait(&vazio);     // Espera até haver espaço livre
    sem_wait(&mutex);     // Entra na seção crítica

    printf("> Produtor %ld entrou em ação!\n", i);

    produto = gera_rand(100);

    if (buffer[in] != -1)
    {
        printf("==== ALERTA DO PRODUTOR %ld ====\n", i);
        printf("Posicao %d ocupada com o valor %d\n", in, buffer[in]);
        printf("===============================\n");
    }

    printf("\t> Produtor %ld vai gravar o valor %d na pos %d\n", i, produto, in);
    buffer[in] = produto;
    in = (in + 1) % N_BUFFER;

    sem_post(&mutex);     // Sai da seção crítica
    sem_post(&cheio);     // Indica item disponível

    return NULL;
}

int gera_rand(int limit)
{
    return rand() % limit;
}

void print_buffer()
{
    int i;
    printf("\t== BUFFER ==\n");
    for (i = 0; i < N_BUFFER; i++)
    {
        printf("\ti: %d | v: %d\n", i, buffer[i]);
    }
    printf("\n");
}
